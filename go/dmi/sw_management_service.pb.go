// Code generated by protoc-gen-go. DO NOT EDIT.
// source: dmi/sw_management_service.proto

package dmi

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GetSoftwareVersionInformationResponse_Reason int32

const (
	GetSoftwareVersionInformationResponse_UNDEFINED_REASON   GetSoftwareVersionInformationResponse_Reason = 0
	GetSoftwareVersionInformationResponse_UNKNOWN_DEVICE     GetSoftwareVersionInformationResponse_Reason = 1
	GetSoftwareVersionInformationResponse_INTERNAL_ERROR     GetSoftwareVersionInformationResponse_Reason = 2
	GetSoftwareVersionInformationResponse_DEVICE_UNREACHABLE GetSoftwareVersionInformationResponse_Reason = 3
)

var GetSoftwareVersionInformationResponse_Reason_name = map[int32]string{
	0: "UNDEFINED_REASON",
	1: "UNKNOWN_DEVICE",
	2: "INTERNAL_ERROR",
	3: "DEVICE_UNREACHABLE",
}

var GetSoftwareVersionInformationResponse_Reason_value = map[string]int32{
	"UNDEFINED_REASON":   0,
	"UNKNOWN_DEVICE":     1,
	"INTERNAL_ERROR":     2,
	"DEVICE_UNREACHABLE": 3,
}

func (x GetSoftwareVersionInformationResponse_Reason) String() string {
	return proto.EnumName(GetSoftwareVersionInformationResponse_Reason_name, int32(x))
}

func (GetSoftwareVersionInformationResponse_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{1, 0}
}

type ConfigResponse_Reason int32

const (
	ConfigResponse_UNDEFINED_REASON              ConfigResponse_Reason = 0
	ConfigResponse_UNKNOWN_DEVICE                ConfigResponse_Reason = 1
	ConfigResponse_INTERNAL_ERROR                ConfigResponse_Reason = 2
	ConfigResponse_ERROR_FETCHING_CONFIG         ConfigResponse_Reason = 3
	ConfigResponse_INVALID_CONFIG                ConfigResponse_Reason = 4
	ConfigResponse_OPERATION_ALREADY_IN_PROGRESS ConfigResponse_Reason = 5
	ConfigResponse_DEVICE_UNREACHABLE            ConfigResponse_Reason = 6
)

var ConfigResponse_Reason_name = map[int32]string{
	0: "UNDEFINED_REASON",
	1: "UNKNOWN_DEVICE",
	2: "INTERNAL_ERROR",
	3: "ERROR_FETCHING_CONFIG",
	4: "INVALID_CONFIG",
	5: "OPERATION_ALREADY_IN_PROGRESS",
	6: "DEVICE_UNREACHABLE",
}

var ConfigResponse_Reason_value = map[string]int32{
	"UNDEFINED_REASON":              0,
	"UNKNOWN_DEVICE":                1,
	"INTERNAL_ERROR":                2,
	"ERROR_FETCHING_CONFIG":         3,
	"INVALID_CONFIG":                4,
	"OPERATION_ALREADY_IN_PROGRESS": 5,
	"DEVICE_UNREACHABLE":            6,
}

func (x ConfigResponse_Reason) String() string {
	return proto.EnumName(ConfigResponse_Reason_name, int32(x))
}

func (ConfigResponse_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{4, 0}
}

type StartupConfigInfoResponse_Reason int32

const (
	StartupConfigInfoResponse_UNDEFINED_REASON   StartupConfigInfoResponse_Reason = 0
	StartupConfigInfoResponse_UNKNOWN_DEVICE     StartupConfigInfoResponse_Reason = 1
	StartupConfigInfoResponse_INTERNAL_ERROR     StartupConfigInfoResponse_Reason = 2
	StartupConfigInfoResponse_DEVICE_UNREACHABLE StartupConfigInfoResponse_Reason = 3
)

var StartupConfigInfoResponse_Reason_name = map[int32]string{
	0: "UNDEFINED_REASON",
	1: "UNKNOWN_DEVICE",
	2: "INTERNAL_ERROR",
	3: "DEVICE_UNREACHABLE",
}

var StartupConfigInfoResponse_Reason_value = map[string]int32{
	"UNDEFINED_REASON":   0,
	"UNKNOWN_DEVICE":     1,
	"INTERNAL_ERROR":     2,
	"DEVICE_UNREACHABLE": 3,
}

func (x StartupConfigInfoResponse_Reason) String() string {
	return proto.EnumName(StartupConfigInfoResponse_Reason_name, int32(x))
}

func (StartupConfigInfoResponse_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{6, 0}
}

type UploadDebugInfoResponse_Reason int32

const (
	UploadDebugInfoResponse_UNDEFINED_REASON                  UploadDebugInfoResponse_Reason = 0
	UploadDebugInfoResponse_UNKNOWN_DEVICE                    UploadDebugInfoResponse_Reason = 1
	UploadDebugInfoResponse_INTERNAL_ERROR                    UploadDebugInfoResponse_Reason = 2
	UploadDebugInfoResponse_DEVICE_UNREACHABLE                UploadDebugInfoResponse_Reason = 3
	UploadDebugInfoResponse_REMOTE_LOCATION_UNREACHABLE       UploadDebugInfoResponse_Reason = 4
	UploadDebugInfoResponse_REMOTE_LOCATION_PERMISSION_DENIED UploadDebugInfoResponse_Reason = 5
	UploadDebugInfoResponse_ERROR_DURING_UPLOAD               UploadDebugInfoResponse_Reason = 6
)

var UploadDebugInfoResponse_Reason_name = map[int32]string{
	0: "UNDEFINED_REASON",
	1: "UNKNOWN_DEVICE",
	2: "INTERNAL_ERROR",
	3: "DEVICE_UNREACHABLE",
	4: "REMOTE_LOCATION_UNREACHABLE",
	5: "REMOTE_LOCATION_PERMISSION_DENIED",
	6: "ERROR_DURING_UPLOAD",
}

var UploadDebugInfoResponse_Reason_value = map[string]int32{
	"UNDEFINED_REASON":                  0,
	"UNKNOWN_DEVICE":                    1,
	"INTERNAL_ERROR":                    2,
	"DEVICE_UNREACHABLE":                3,
	"REMOTE_LOCATION_UNREACHABLE":       4,
	"REMOTE_LOCATION_PERMISSION_DENIED": 5,
	"ERROR_DURING_UPLOAD":               6,
}

func (x UploadDebugInfoResponse_Reason) String() string {
	return proto.EnumName(UploadDebugInfoResponse_Reason_name, int32(x))
}

func (UploadDebugInfoResponse_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{8, 0}
}

type SoftwareVersionInformation struct {
	ActiveVersions       []*ImageVersion `protobuf:"bytes,1,rep,name=active_versions,json=activeVersions,proto3" json:"active_versions,omitempty"`
	StandbyVersions      []*ImageVersion `protobuf:"bytes,2,rep,name=standby_versions,json=standbyVersions,proto3" json:"standby_versions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SoftwareVersionInformation) Reset()         { *m = SoftwareVersionInformation{} }
func (m *SoftwareVersionInformation) String() string { return proto.CompactTextString(m) }
func (*SoftwareVersionInformation) ProtoMessage()    {}
func (*SoftwareVersionInformation) Descriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{0}
}

func (m *SoftwareVersionInformation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SoftwareVersionInformation.Unmarshal(m, b)
}
func (m *SoftwareVersionInformation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SoftwareVersionInformation.Marshal(b, m, deterministic)
}
func (m *SoftwareVersionInformation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SoftwareVersionInformation.Merge(m, src)
}
func (m *SoftwareVersionInformation) XXX_Size() int {
	return xxx_messageInfo_SoftwareVersionInformation.Size(m)
}
func (m *SoftwareVersionInformation) XXX_DiscardUnknown() {
	xxx_messageInfo_SoftwareVersionInformation.DiscardUnknown(m)
}

var xxx_messageInfo_SoftwareVersionInformation proto.InternalMessageInfo

func (m *SoftwareVersionInformation) GetActiveVersions() []*ImageVersion {
	if m != nil {
		return m.ActiveVersions
	}
	return nil
}

func (m *SoftwareVersionInformation) GetStandbyVersions() []*ImageVersion {
	if m != nil {
		return m.StandbyVersions
	}
	return nil
}

type GetSoftwareVersionInformationResponse struct {
	Status               Status                                       `protobuf:"varint,1,opt,name=status,proto3,enum=dmi.Status" json:"status,omitempty"`
	Reason               GetSoftwareVersionInformationResponse_Reason `protobuf:"varint,2,opt,name=reason,proto3,enum=dmi.GetSoftwareVersionInformationResponse_Reason" json:"reason,omitempty"`
	Info                 *SoftwareVersionInformation                  `protobuf:"bytes,3,opt,name=info,proto3" json:"info,omitempty"`
	ReasonDetail         string                                       `protobuf:"bytes,4,opt,name=reason_detail,json=reasonDetail,proto3" json:"reason_detail,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *GetSoftwareVersionInformationResponse) Reset()         { *m = GetSoftwareVersionInformationResponse{} }
func (m *GetSoftwareVersionInformationResponse) String() string { return proto.CompactTextString(m) }
func (*GetSoftwareVersionInformationResponse) ProtoMessage()    {}
func (*GetSoftwareVersionInformationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{1}
}

func (m *GetSoftwareVersionInformationResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetSoftwareVersionInformationResponse.Unmarshal(m, b)
}
func (m *GetSoftwareVersionInformationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetSoftwareVersionInformationResponse.Marshal(b, m, deterministic)
}
func (m *GetSoftwareVersionInformationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSoftwareVersionInformationResponse.Merge(m, src)
}
func (m *GetSoftwareVersionInformationResponse) XXX_Size() int {
	return xxx_messageInfo_GetSoftwareVersionInformationResponse.Size(m)
}
func (m *GetSoftwareVersionInformationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSoftwareVersionInformationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSoftwareVersionInformationResponse proto.InternalMessageInfo

func (m *GetSoftwareVersionInformationResponse) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_UNDEFINED_STATUS
}

func (m *GetSoftwareVersionInformationResponse) GetReason() GetSoftwareVersionInformationResponse_Reason {
	if m != nil {
		return m.Reason
	}
	return GetSoftwareVersionInformationResponse_UNDEFINED_REASON
}

func (m *GetSoftwareVersionInformationResponse) GetInfo() *SoftwareVersionInformation {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *GetSoftwareVersionInformationResponse) GetReasonDetail() string {
	if m != nil {
		return m.ReasonDetail
	}
	return ""
}

type DownloadImageRequest struct {
	DeviceUuid           *Uuid             `protobuf:"bytes,1,opt,name=device_uuid,json=deviceUuid,proto3" json:"device_uuid,omitempty"`
	ImageInfo            *ImageInformation `protobuf:"bytes,2,opt,name=image_info,json=imageInfo,proto3" json:"image_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DownloadImageRequest) Reset()         { *m = DownloadImageRequest{} }
func (m *DownloadImageRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadImageRequest) ProtoMessage()    {}
func (*DownloadImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{2}
}

func (m *DownloadImageRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DownloadImageRequest.Unmarshal(m, b)
}
func (m *DownloadImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DownloadImageRequest.Marshal(b, m, deterministic)
}
func (m *DownloadImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadImageRequest.Merge(m, src)
}
func (m *DownloadImageRequest) XXX_Size() int {
	return xxx_messageInfo_DownloadImageRequest.Size(m)
}
func (m *DownloadImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadImageRequest proto.InternalMessageInfo

func (m *DownloadImageRequest) GetDeviceUuid() *Uuid {
	if m != nil {
		return m.DeviceUuid
	}
	return nil
}

func (m *DownloadImageRequest) GetImageInfo() *ImageInformation {
	if m != nil {
		return m.ImageInfo
	}
	return nil
}

type ConfigRequest struct {
	DeviceUuid *Uuid `protobuf:"bytes,1,opt,name=device_uuid,json=deviceUuid,proto3" json:"device_uuid,omitempty"`
	// Location of the configuration file, authentication (user/pass) if any should be in the url string
	// The config_url would contain the protocol, credentials, the IP address/DNS of the server and the path of the file
	// e.g. sftp://download_user:download_pass@192.168.0.1:22/OLT-configs/config-v1.2.3.xml
	ConfigUrl            string   `protobuf:"bytes,2,opt,name=config_url,json=configUrl,proto3" json:"config_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigRequest) Reset()         { *m = ConfigRequest{} }
func (m *ConfigRequest) String() string { return proto.CompactTextString(m) }
func (*ConfigRequest) ProtoMessage()    {}
func (*ConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{3}
}

func (m *ConfigRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigRequest.Unmarshal(m, b)
}
func (m *ConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigRequest.Marshal(b, m, deterministic)
}
func (m *ConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigRequest.Merge(m, src)
}
func (m *ConfigRequest) XXX_Size() int {
	return xxx_messageInfo_ConfigRequest.Size(m)
}
func (m *ConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigRequest proto.InternalMessageInfo

func (m *ConfigRequest) GetDeviceUuid() *Uuid {
	if m != nil {
		return m.DeviceUuid
	}
	return nil
}

func (m *ConfigRequest) GetConfigUrl() string {
	if m != nil {
		return m.ConfigUrl
	}
	return ""
}

type ConfigResponse struct {
	Status               Status                `protobuf:"varint,1,opt,name=status,proto3,enum=dmi.Status" json:"status,omitempty"`
	Reason               ConfigResponse_Reason `protobuf:"varint,2,opt,name=reason,proto3,enum=dmi.ConfigResponse_Reason" json:"reason,omitempty"`
	ReasonDetail         string                `protobuf:"bytes,3,opt,name=reason_detail,json=reasonDetail,proto3" json:"reason_detail,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ConfigResponse) Reset()         { *m = ConfigResponse{} }
func (m *ConfigResponse) String() string { return proto.CompactTextString(m) }
func (*ConfigResponse) ProtoMessage()    {}
func (*ConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{4}
}

func (m *ConfigResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigResponse.Unmarshal(m, b)
}
func (m *ConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigResponse.Marshal(b, m, deterministic)
}
func (m *ConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigResponse.Merge(m, src)
}
func (m *ConfigResponse) XXX_Size() int {
	return xxx_messageInfo_ConfigResponse.Size(m)
}
func (m *ConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigResponse proto.InternalMessageInfo

func (m *ConfigResponse) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_UNDEFINED_STATUS
}

func (m *ConfigResponse) GetReason() ConfigResponse_Reason {
	if m != nil {
		return m.Reason
	}
	return ConfigResponse_UNDEFINED_REASON
}

func (m *ConfigResponse) GetReasonDetail() string {
	if m != nil {
		return m.ReasonDetail
	}
	return ""
}

type StartupConfigInfoRequest struct {
	DeviceUuid           *Uuid    `protobuf:"bytes,1,opt,name=device_uuid,json=deviceUuid,proto3" json:"device_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartupConfigInfoRequest) Reset()         { *m = StartupConfigInfoRequest{} }
func (m *StartupConfigInfoRequest) String() string { return proto.CompactTextString(m) }
func (*StartupConfigInfoRequest) ProtoMessage()    {}
func (*StartupConfigInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{5}
}

func (m *StartupConfigInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartupConfigInfoRequest.Unmarshal(m, b)
}
func (m *StartupConfigInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartupConfigInfoRequest.Marshal(b, m, deterministic)
}
func (m *StartupConfigInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartupConfigInfoRequest.Merge(m, src)
}
func (m *StartupConfigInfoRequest) XXX_Size() int {
	return xxx_messageInfo_StartupConfigInfoRequest.Size(m)
}
func (m *StartupConfigInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartupConfigInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartupConfigInfoRequest proto.InternalMessageInfo

func (m *StartupConfigInfoRequest) GetDeviceUuid() *Uuid {
	if m != nil {
		return m.DeviceUuid
	}
	return nil
}

type StartupConfigInfoResponse struct {
	Status Status                           `protobuf:"varint,1,opt,name=status,proto3,enum=dmi.Status" json:"status,omitempty"`
	Reason StartupConfigInfoResponse_Reason `protobuf:"varint,2,opt,name=reason,proto3,enum=dmi.StartupConfigInfoResponse_Reason" json:"reason,omitempty"`
	// The config_url is an optional attribute, the device manager could return the location from
	// where the config was downloaded. Also it would not be present/empty for a fresh device into which the
	// startup config would have been installed in the factory.
	ConfigUrl string `protobuf:"bytes,3,opt,name=config_url,json=configUrl,proto3" json:"config_url,omitempty"`
	// The version of the startup configuration. It is recommended to use semVer, but the DM implementations
	// and operators could choose any other format as well.
	Version              string   `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	ReasonDetail         string   `protobuf:"bytes,5,opt,name=reason_detail,json=reasonDetail,proto3" json:"reason_detail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartupConfigInfoResponse) Reset()         { *m = StartupConfigInfoResponse{} }
func (m *StartupConfigInfoResponse) String() string { return proto.CompactTextString(m) }
func (*StartupConfigInfoResponse) ProtoMessage()    {}
func (*StartupConfigInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{6}
}

func (m *StartupConfigInfoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartupConfigInfoResponse.Unmarshal(m, b)
}
func (m *StartupConfigInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartupConfigInfoResponse.Marshal(b, m, deterministic)
}
func (m *StartupConfigInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartupConfigInfoResponse.Merge(m, src)
}
func (m *StartupConfigInfoResponse) XXX_Size() int {
	return xxx_messageInfo_StartupConfigInfoResponse.Size(m)
}
func (m *StartupConfigInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartupConfigInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartupConfigInfoResponse proto.InternalMessageInfo

func (m *StartupConfigInfoResponse) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_UNDEFINED_STATUS
}

func (m *StartupConfigInfoResponse) GetReason() StartupConfigInfoResponse_Reason {
	if m != nil {
		return m.Reason
	}
	return StartupConfigInfoResponse_UNDEFINED_REASON
}

func (m *StartupConfigInfoResponse) GetConfigUrl() string {
	if m != nil {
		return m.ConfigUrl
	}
	return ""
}

func (m *StartupConfigInfoResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *StartupConfigInfoResponse) GetReasonDetail() string {
	if m != nil {
		return m.ReasonDetail
	}
	return ""
}

type UploadDebugInfoRequest struct {
	DeviceUuid *Uuid `protobuf:"bytes,1,opt,name=device_uuid,json=deviceUuid,proto3" json:"device_uuid,omitempty"`
	// location_url is the remote location where the information needed for troubeshooting should be uploaded.
	// Authentication (user/pass) if any should be in the location_url string
	// The locaion_url would contain the protocol, credentials, the IP address/DNS of the server and the path of the directory
	// e.g. sftp://upload_user:upload_pass@192.168.0.1:22/hw_debug_info/
	LocationUrl          string   `protobuf:"bytes,3,opt,name=location_url,json=locationUrl,proto3" json:"location_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadDebugInfoRequest) Reset()         { *m = UploadDebugInfoRequest{} }
func (m *UploadDebugInfoRequest) String() string { return proto.CompactTextString(m) }
func (*UploadDebugInfoRequest) ProtoMessage()    {}
func (*UploadDebugInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{7}
}

func (m *UploadDebugInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UploadDebugInfoRequest.Unmarshal(m, b)
}
func (m *UploadDebugInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UploadDebugInfoRequest.Marshal(b, m, deterministic)
}
func (m *UploadDebugInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadDebugInfoRequest.Merge(m, src)
}
func (m *UploadDebugInfoRequest) XXX_Size() int {
	return xxx_messageInfo_UploadDebugInfoRequest.Size(m)
}
func (m *UploadDebugInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadDebugInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadDebugInfoRequest proto.InternalMessageInfo

func (m *UploadDebugInfoRequest) GetDeviceUuid() *Uuid {
	if m != nil {
		return m.DeviceUuid
	}
	return nil
}

func (m *UploadDebugInfoRequest) GetLocationUrl() string {
	if m != nil {
		return m.LocationUrl
	}
	return ""
}

type UploadDebugInfoResponse struct {
	DeviceUuid  *Uuid                          `protobuf:"bytes,1,opt,name=device_uuid,json=deviceUuid,proto3" json:"device_uuid,omitempty"`
	Status      Status                         `protobuf:"varint,2,opt,name=status,proto3,enum=dmi.Status" json:"status,omitempty"`
	Reason      UploadDebugInfoResponse_Reason `protobuf:"varint,3,opt,name=reason,proto3,enum=dmi.UploadDebugInfoResponse_Reason" json:"reason,omitempty"`
	LocationUrl string                         `protobuf:"bytes,4,opt,name=location_url,json=locationUrl,proto3" json:"location_url,omitempty"`
	// file_name is the file at location_url where the debug information was uploaded.
	// Implementations need to ensure that file_name is unique at the remote location.
	FileName             string   `protobuf:"bytes,5,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadDebugInfoResponse) Reset()         { *m = UploadDebugInfoResponse{} }
func (m *UploadDebugInfoResponse) String() string { return proto.CompactTextString(m) }
func (*UploadDebugInfoResponse) ProtoMessage()    {}
func (*UploadDebugInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_000929e4bec891d7, []int{8}
}

func (m *UploadDebugInfoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UploadDebugInfoResponse.Unmarshal(m, b)
}
func (m *UploadDebugInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UploadDebugInfoResponse.Marshal(b, m, deterministic)
}
func (m *UploadDebugInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadDebugInfoResponse.Merge(m, src)
}
func (m *UploadDebugInfoResponse) XXX_Size() int {
	return xxx_messageInfo_UploadDebugInfoResponse.Size(m)
}
func (m *UploadDebugInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadDebugInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadDebugInfoResponse proto.InternalMessageInfo

func (m *UploadDebugInfoResponse) GetDeviceUuid() *Uuid {
	if m != nil {
		return m.DeviceUuid
	}
	return nil
}

func (m *UploadDebugInfoResponse) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_UNDEFINED_STATUS
}

func (m *UploadDebugInfoResponse) GetReason() UploadDebugInfoResponse_Reason {
	if m != nil {
		return m.Reason
	}
	return UploadDebugInfoResponse_UNDEFINED_REASON
}

func (m *UploadDebugInfoResponse) GetLocationUrl() string {
	if m != nil {
		return m.LocationUrl
	}
	return ""
}

func (m *UploadDebugInfoResponse) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func init() {
	proto.RegisterEnum("dmi.GetSoftwareVersionInformationResponse_Reason", GetSoftwareVersionInformationResponse_Reason_name, GetSoftwareVersionInformationResponse_Reason_value)
	proto.RegisterEnum("dmi.ConfigResponse_Reason", ConfigResponse_Reason_name, ConfigResponse_Reason_value)
	proto.RegisterEnum("dmi.StartupConfigInfoResponse_Reason", StartupConfigInfoResponse_Reason_name, StartupConfigInfoResponse_Reason_value)
	proto.RegisterEnum("dmi.UploadDebugInfoResponse_Reason", UploadDebugInfoResponse_Reason_name, UploadDebugInfoResponse_Reason_value)
	proto.RegisterType((*SoftwareVersionInformation)(nil), "dmi.SoftwareVersionInformation")
	proto.RegisterType((*GetSoftwareVersionInformationResponse)(nil), "dmi.GetSoftwareVersionInformationResponse")
	proto.RegisterType((*DownloadImageRequest)(nil), "dmi.DownloadImageRequest")
	proto.RegisterType((*ConfigRequest)(nil), "dmi.ConfigRequest")
	proto.RegisterType((*ConfigResponse)(nil), "dmi.ConfigResponse")
	proto.RegisterType((*StartupConfigInfoRequest)(nil), "dmi.StartupConfigInfoRequest")
	proto.RegisterType((*StartupConfigInfoResponse)(nil), "dmi.StartupConfigInfoResponse")
	proto.RegisterType((*UploadDebugInfoRequest)(nil), "dmi.UploadDebugInfoRequest")
	proto.RegisterType((*UploadDebugInfoResponse)(nil), "dmi.UploadDebugInfoResponse")
}

func init() { proto.RegisterFile("dmi/sw_management_service.proto", fileDescriptor_000929e4bec891d7) }

var fileDescriptor_000929e4bec891d7 = []byte{
	// 965 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xc6, 0x49, 0x1a, 0xc8, 0x49, 0x7f, 0xbc, 0xb3, 0xdd, 0xdd, 0x34, 0xa5, 0xb4, 0x4d, 0x55,
	0xa9, 0x5a, 0x69, 0x9b, 0x92, 0xee, 0x0d, 0x14, 0x90, 0xbc, 0xb1, 0x9b, 0x5a, 0xa4, 0x76, 0x19,
	0x27, 0x45, 0xac, 0x10, 0xd6, 0x34, 0x9e, 0x64, 0x2d, 0xc5, 0x9e, 0xe0, 0x9f, 0x14, 0x5e, 0x84,
	0x4b, 0xee, 0xb9, 0xe3, 0x05, 0x10, 0xe2, 0x11, 0x78, 0x23, 0xe4, 0x19, 0x67, 0xd3, 0x24, 0xce,
	0x6a, 0x5b, 0x81, 0xb8, 0xb3, 0xcf, 0x7c, 0xe7, 0x3b, 0x33, 0xf3, 0x9d, 0x33, 0xe7, 0xc0, 0xae,
	0xe3, 0xb9, 0xf5, 0xf0, 0xd6, 0xf6, 0x88, 0x4f, 0x06, 0xd4, 0xa3, 0x7e, 0x64, 0x87, 0x34, 0x18,
	0xbb, 0x3d, 0x7a, 0x3c, 0x0a, 0x58, 0xc4, 0x50, 0xde, 0xf1, 0xdc, 0xea, 0xa3, 0x04, 0xd5, 0x63,
	0x9e, 0xc7, 0xfc, 0x50, 0xd8, 0xab, 0xab, 0x89, 0xe9, 0xcd, 0x6d, 0xfa, 0x87, 0x52, 0x1a, 0xd7,
	0x23, 0x83, 0xd4, 0xb3, 0xf6, 0x8b, 0x04, 0x55, 0x8b, 0xf5, 0xa3, 0x5b, 0x12, 0xd0, 0x6b, 0x1a,
	0x84, 0x2e, 0xf3, 0x75, 0xbf, 0xcf, 0x02, 0x8f, 0x44, 0x2e, 0xf3, 0xd1, 0xe7, 0xb0, 0x41, 0x7a,
	0x91, 0x3b, 0xa6, 0xf6, 0x58, 0x2c, 0x86, 0x15, 0x69, 0x2f, 0x7f, 0x54, 0x6e, 0x3c, 0x3a, 0x76,
	0x3c, 0xf7, 0x58, 0x4f, 0x98, 0x52, 0x37, 0xbc, 0x2e, 0x90, 0xe9, 0x6f, 0x88, 0xbe, 0x00, 0x39,
	0x8c, 0x88, 0xef, 0xdc, 0xfc, 0x3c, 0x75, 0xce, 0x2d, 0x73, 0xde, 0x48, 0xa1, 0x13, 0xef, 0xda,
	0xdf, 0x39, 0x38, 0x6c, 0xd1, 0x68, 0xf9, 0xde, 0x30, 0x0d, 0x47, 0xcc, 0x0f, 0x29, 0x3a, 0x80,
	0x62, 0x18, 0x91, 0x28, 0x4e, 0xb6, 0x26, 0x1d, 0xad, 0x37, 0xca, 0x9c, 0xdd, 0xe2, 0x26, 0x9c,
	0x2e, 0x21, 0x1d, 0x8a, 0x01, 0x25, 0x21, 0xf3, 0x2b, 0x39, 0x0e, 0xfa, 0x94, 0x83, 0xde, 0x2b,
	0xc0, 0x31, 0xe6, 0x8e, 0x38, 0x25, 0x40, 0xa7, 0x50, 0x70, 0xfd, 0x3e, 0xab, 0xe4, 0xf7, 0xa4,
	0xa3, 0x72, 0x63, 0x57, 0x44, 0x5b, 0xce, 0xc2, 0xc1, 0xe8, 0x00, 0xd6, 0x84, 0xbb, 0xed, 0xd0,
	0x88, 0xb8, 0xc3, 0x4a, 0x61, 0x4f, 0x3a, 0x2a, 0xe1, 0x55, 0x61, 0x54, 0xb9, 0xad, 0xf6, 0x03,
	0x14, 0x45, 0x2c, 0xb4, 0x09, 0x72, 0xd7, 0x50, 0xb5, 0x73, 0xdd, 0xd0, 0x54, 0x1b, 0x6b, 0x8a,
	0x65, 0x1a, 0xf2, 0x07, 0x08, 0xc1, 0x7a, 0xd7, 0xf8, 0xda, 0x30, 0xbf, 0x35, 0x6c, 0x55, 0xbb,
	0xd6, 0x9b, 0x9a, 0x2c, 0x25, 0x36, 0xdd, 0xe8, 0x68, 0xd8, 0x50, 0xda, 0xb6, 0x86, 0xb1, 0x89,
	0xe5, 0x1c, 0x7a, 0x0a, 0x48, 0xac, 0xdb, 0x5d, 0x03, 0x6b, 0x4a, 0xf3, 0x42, 0x79, 0xd5, 0xd6,
	0xe4, 0x7c, 0xed, 0x27, 0xd8, 0x54, 0xd9, 0xad, 0x3f, 0x64, 0xc4, 0xe1, 0x97, 0x8f, 0xe9, 0x8f,
	0x31, 0x0d, 0x23, 0xf4, 0x1c, 0xca, 0x0e, 0x4d, 0xd2, 0xc9, 0x8e, 0x63, 0xd7, 0xe1, 0xd7, 0x58,
	0x6e, 0x94, 0xf8, 0xc1, 0xba, 0xb1, 0xeb, 0x60, 0x10, 0xab, 0xc9, 0x37, 0x7a, 0x09, 0xc0, 0xf3,
	0xc7, 0xe6, 0x77, 0x90, 0xe3, 0xd0, 0x27, 0x53, 0x3d, 0xef, 0x9e, 0xbc, 0xe4, 0x4e, 0x2c, 0xb5,
	0xd7, 0xb0, 0xd6, 0x64, 0x7e, 0xdf, 0x1d, 0x3c, 0x24, 0xe4, 0x0e, 0x40, 0x8f, 0x3b, 0xdb, 0x71,
	0x30, 0xe4, 0x21, 0x4b, 0xb8, 0x24, 0x2c, 0xdd, 0x60, 0x58, 0xfb, 0x2b, 0x07, 0xeb, 0x13, 0xf2,
	0xfb, 0xa4, 0x44, 0x63, 0x2e, 0x25, 0xaa, 0x1c, 0x34, 0xcb, 0x34, 0xaf, 0xfd, 0x82, 0x8c, 0xf9,
	0x0c, 0x19, 0x7f, 0x97, 0xfe, 0x25, 0x1d, 0xb7, 0xe0, 0x09, 0xff, 0xb4, 0xcf, 0xb5, 0x4e, 0xf3,
	0x42, 0x37, 0x5a, 0x76, 0xd3, 0x34, 0xce, 0xf5, 0x96, 0x9c, 0x17, 0xf0, 0x6b, 0xa5, 0xad, 0xab,
	0x13, 0x5b, 0x01, 0xed, 0xc3, 0x8e, 0x79, 0xa5, 0x61, 0xa5, 0xa3, 0x9b, 0x86, 0xad, 0xb4, 0xb1,
	0xa6, 0xa8, 0xdf, 0xd9, 0xba, 0x61, 0x5f, 0x61, 0xb3, 0x85, 0x35, 0xcb, 0x92, 0x57, 0x96, 0x64,
	0x46, 0xb1, 0x76, 0x0e, 0x15, 0x2b, 0x22, 0x41, 0x14, 0x8f, 0xc4, 0xf9, 0x13, 0xd1, 0x1e, 0x20,
	0x55, 0xed, 0x8f, 0x1c, 0x6c, 0x65, 0x10, 0xdd, 0x47, 0x96, 0x2f, 0xe7, 0x64, 0x39, 0x9c, 0x80,
	0xb2, 0x49, 0xe7, 0x15, 0x9a, 0x4d, 0x96, 0xfc, 0x5c, 0xb2, 0xa0, 0x0a, 0x7c, 0x98, 0x3e, 0x46,
	0x69, 0x05, 0x4e, 0x7e, 0x17, 0xa5, 0x5d, 0xf9, 0x1f, 0x2a, 0x74, 0x00, 0x4f, 0xbb, 0xa3, 0xa4,
	0x3e, 0x55, 0x7a, 0x13, 0x3f, 0x54, 0x05, 0xb4, 0x0f, 0xab, 0x43, 0xd6, 0xe3, 0x45, 0x78, 0xe7,
	0x16, 0xca, 0x13, 0x5b, 0x52, 0x34, 0xbf, 0xe5, 0xe1, 0xd9, 0x42, 0xa4, 0x54, 0xa6, 0xfb, 0x84,
	0x9a, 0x4a, 0x9a, 0x5b, 0x2e, 0xe9, 0xd9, 0x5b, 0x49, 0xf3, 0x1c, 0x74, 0x20, 0xb8, 0xb2, 0xc3,
	0xcf, 0x0b, 0x3a, 0x7f, 0x98, 0xc2, 0xc2, 0x61, 0xd0, 0x36, 0x94, 0xfa, 0xee, 0x90, 0xda, 0x3e,
	0xf1, 0x68, 0x2a, 0xdb, 0x47, 0x89, 0xc1, 0x20, 0x1e, 0xad, 0xfd, 0x29, 0xfd, 0xb7, 0x9a, 0xa1,
	0x5d, 0xd8, 0xc6, 0xda, 0xa5, 0xd9, 0xd1, 0xec, 0xb6, 0xd9, 0x14, 0xc5, 0x77, 0x17, 0x50, 0x40,
	0x87, 0xb0, 0x3f, 0x0f, 0xb8, 0xd2, 0xf0, 0xa5, 0x6e, 0x59, 0xc9, 0xa7, 0xaa, 0x19, 0xba, 0xa6,
	0xca, 0x2b, 0xe8, 0x19, 0x3c, 0x16, 0xd5, 0xae, 0x76, 0x71, 0x52, 0xeb, 0xdd, 0xab, 0xb6, 0xa9,
	0xa8, 0x72, 0xb1, 0xf1, 0x6b, 0x01, 0x76, 0x0d, 0x92, 0xf4, 0xd6, 0x49, 0x9b, 0xb9, 0x7c, 0x3b,
	0x08, 0x58, 0x62, 0x0e, 0x40, 0xdf, 0x00, 0x5a, 0x6c, 0x66, 0x68, 0x83, 0x5f, 0xf4, 0x05, 0x09,
	0x9c, 0xc4, 0xaa, 0xab, 0xd5, 0xe7, 0xef, 0xdf, 0xf6, 0xd0, 0x57, 0xb0, 0x36, 0xd3, 0x2d, 0xd0,
	0x16, 0x77, 0xce, 0xea, 0x20, 0x55, 0x79, 0xda, 0x01, 0x84, 0xf6, 0x27, 0x12, 0x7a, 0x09, 0x6b,
	0x4a, 0x32, 0x11, 0x90, 0x88, 0x0a, 0xff, 0x85, 0xdd, 0x64, 0x79, 0x9d, 0xc1, 0x26, 0xa6, 0x63,
	0x1a, 0x44, 0x1d, 0x66, 0x89, 0x91, 0xe0, 0x1e, 0xce, 0x2d, 0xa8, 0x76, 0x47, 0x0e, 0x89, 0xe8,
	0xcc, 0x73, 0x11, 0x07, 0x62, 0x98, 0x41, 0x33, 0x0f, 0xbc, 0xd8, 0xf8, 0xe3, 0x8c, 0x47, 0xff,
	0x44, 0x42, 0xdf, 0xc3, 0x76, 0x72, 0x49, 0x19, 0x2c, 0xc9, 0x4d, 0xa1, 0x9d, 0x65, 0x6f, 0x92,
	0x20, 0xfd, 0xe4, 0xdd, 0x4f, 0x16, 0x32, 0x60, 0x63, 0x2e, 0xf9, 0xd1, 0x76, 0x76, 0x49, 0x08,
	0xbe, 0x8f, 0xdf, 0x55, 0x2f, 0x27, 0xd2, 0xab, 0xb3, 0xd7, 0x9f, 0x0d, 0xdc, 0xe8, 0x4d, 0x7c,
	0x73, 0xdc, 0x63, 0x5e, 0x9d, 0x8d, 0xa8, 0xdf, 0x63, 0x81, 0x53, 0x17, 0x65, 0xfa, 0x62, 0x3a,
	0x35, 0xbe, 0x70, 0xfd, 0x88, 0x06, 0x7d, 0xd2, 0xa3, 0xf5, 0xf1, 0x69, 0x7d, 0xc0, 0xea, 0x8e,
	0xe7, 0xde, 0x14, 0xf9, 0x20, 0x78, 0xfa, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc9, 0x6f, 0x73,
	0xaa, 0x65, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NativeSoftwareManagementServiceClient is the client API for NativeSoftwareManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NativeSoftwareManagementServiceClient interface {
	// Get the software version information of the Active and Standby images
	GetSoftwareVersion(ctx context.Context, in *HardwareID, opts ...grpc.CallOption) (*GetSoftwareVersionInformationResponse, error)
	// Downloads and installs the image in the standby partition, returns the status/progress of the Install
	DownloadImage(ctx context.Context, in *DownloadImageRequest, opts ...grpc.CallOption) (NativeSoftwareManagementService_DownloadImageClient, error)
	// Activates and runs the OLT with the image in the standby partition. If things are fine this image will
	// henceforth be marked as the Active Partition. The old working image would remain on the Standby partition.
	// Any possibly required (sub-)steps like "commit" are left to the "Device Manager"
	ActivateImage(ctx context.Context, in *HardwareID, opts ...grpc.CallOption) (NativeSoftwareManagementService_ActivateImageClient, error)
	// Marks the image in the Standby as Active and reboots the device, so that it boots from that image which was in the standby.
	// This API is to be used if operator wants to go back to the previous software
	RevertToStandbyImage(ctx context.Context, in *HardwareID, opts ...grpc.CallOption) (NativeSoftwareManagementService_RevertToStandbyImageClient, error)
	// This API can be used to let the devices pickup their properitary configuration which they need at startup.
	UpdateStartupConfiguration(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (NativeSoftwareManagementService_UpdateStartupConfigurationClient, error)
	// This API can be used to retrieve information about the current startup configuration that a device is using
	GetStartupConfigurationInfo(ctx context.Context, in *StartupConfigInfoRequest, opts ...grpc.CallOption) (*StartupConfigInfoResponse, error)
	// This API can be used to upload to a remote location, information useful for troubleshooting problems on the hardware
	UploadDebugInfo(ctx context.Context, in *UploadDebugInfoRequest, opts ...grpc.CallOption) (NativeSoftwareManagementService_UploadDebugInfoClient, error)
}

type nativeSoftwareManagementServiceClient struct {
	cc *grpc.ClientConn
}

func NewNativeSoftwareManagementServiceClient(cc *grpc.ClientConn) NativeSoftwareManagementServiceClient {
	return &nativeSoftwareManagementServiceClient{cc}
}

func (c *nativeSoftwareManagementServiceClient) GetSoftwareVersion(ctx context.Context, in *HardwareID, opts ...grpc.CallOption) (*GetSoftwareVersionInformationResponse, error) {
	out := new(GetSoftwareVersionInformationResponse)
	err := c.cc.Invoke(ctx, "/dmi.NativeSoftwareManagementService/GetSoftwareVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nativeSoftwareManagementServiceClient) DownloadImage(ctx context.Context, in *DownloadImageRequest, opts ...grpc.CallOption) (NativeSoftwareManagementService_DownloadImageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NativeSoftwareManagementService_serviceDesc.Streams[0], "/dmi.NativeSoftwareManagementService/DownloadImage", opts...)
	if err != nil {
		return nil, err
	}
	x := &nativeSoftwareManagementServiceDownloadImageClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NativeSoftwareManagementService_DownloadImageClient interface {
	Recv() (*ImageStatus, error)
	grpc.ClientStream
}

type nativeSoftwareManagementServiceDownloadImageClient struct {
	grpc.ClientStream
}

func (x *nativeSoftwareManagementServiceDownloadImageClient) Recv() (*ImageStatus, error) {
	m := new(ImageStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nativeSoftwareManagementServiceClient) ActivateImage(ctx context.Context, in *HardwareID, opts ...grpc.CallOption) (NativeSoftwareManagementService_ActivateImageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NativeSoftwareManagementService_serviceDesc.Streams[1], "/dmi.NativeSoftwareManagementService/ActivateImage", opts...)
	if err != nil {
		return nil, err
	}
	x := &nativeSoftwareManagementServiceActivateImageClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NativeSoftwareManagementService_ActivateImageClient interface {
	Recv() (*ImageStatus, error)
	grpc.ClientStream
}

type nativeSoftwareManagementServiceActivateImageClient struct {
	grpc.ClientStream
}

func (x *nativeSoftwareManagementServiceActivateImageClient) Recv() (*ImageStatus, error) {
	m := new(ImageStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nativeSoftwareManagementServiceClient) RevertToStandbyImage(ctx context.Context, in *HardwareID, opts ...grpc.CallOption) (NativeSoftwareManagementService_RevertToStandbyImageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NativeSoftwareManagementService_serviceDesc.Streams[2], "/dmi.NativeSoftwareManagementService/RevertToStandbyImage", opts...)
	if err != nil {
		return nil, err
	}
	x := &nativeSoftwareManagementServiceRevertToStandbyImageClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NativeSoftwareManagementService_RevertToStandbyImageClient interface {
	Recv() (*ImageStatus, error)
	grpc.ClientStream
}

type nativeSoftwareManagementServiceRevertToStandbyImageClient struct {
	grpc.ClientStream
}

func (x *nativeSoftwareManagementServiceRevertToStandbyImageClient) Recv() (*ImageStatus, error) {
	m := new(ImageStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nativeSoftwareManagementServiceClient) UpdateStartupConfiguration(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (NativeSoftwareManagementService_UpdateStartupConfigurationClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NativeSoftwareManagementService_serviceDesc.Streams[3], "/dmi.NativeSoftwareManagementService/UpdateStartupConfiguration", opts...)
	if err != nil {
		return nil, err
	}
	x := &nativeSoftwareManagementServiceUpdateStartupConfigurationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NativeSoftwareManagementService_UpdateStartupConfigurationClient interface {
	Recv() (*ConfigResponse, error)
	grpc.ClientStream
}

type nativeSoftwareManagementServiceUpdateStartupConfigurationClient struct {
	grpc.ClientStream
}

func (x *nativeSoftwareManagementServiceUpdateStartupConfigurationClient) Recv() (*ConfigResponse, error) {
	m := new(ConfigResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nativeSoftwareManagementServiceClient) GetStartupConfigurationInfo(ctx context.Context, in *StartupConfigInfoRequest, opts ...grpc.CallOption) (*StartupConfigInfoResponse, error) {
	out := new(StartupConfigInfoResponse)
	err := c.cc.Invoke(ctx, "/dmi.NativeSoftwareManagementService/GetStartupConfigurationInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nativeSoftwareManagementServiceClient) UploadDebugInfo(ctx context.Context, in *UploadDebugInfoRequest, opts ...grpc.CallOption) (NativeSoftwareManagementService_UploadDebugInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NativeSoftwareManagementService_serviceDesc.Streams[4], "/dmi.NativeSoftwareManagementService/UploadDebugInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &nativeSoftwareManagementServiceUploadDebugInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NativeSoftwareManagementService_UploadDebugInfoClient interface {
	Recv() (*UploadDebugInfoResponse, error)
	grpc.ClientStream
}

type nativeSoftwareManagementServiceUploadDebugInfoClient struct {
	grpc.ClientStream
}

func (x *nativeSoftwareManagementServiceUploadDebugInfoClient) Recv() (*UploadDebugInfoResponse, error) {
	m := new(UploadDebugInfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NativeSoftwareManagementServiceServer is the server API for NativeSoftwareManagementService service.
type NativeSoftwareManagementServiceServer interface {
	// Get the software version information of the Active and Standby images
	GetSoftwareVersion(context.Context, *HardwareID) (*GetSoftwareVersionInformationResponse, error)
	// Downloads and installs the image in the standby partition, returns the status/progress of the Install
	DownloadImage(*DownloadImageRequest, NativeSoftwareManagementService_DownloadImageServer) error
	// Activates and runs the OLT with the image in the standby partition. If things are fine this image will
	// henceforth be marked as the Active Partition. The old working image would remain on the Standby partition.
	// Any possibly required (sub-)steps like "commit" are left to the "Device Manager"
	ActivateImage(*HardwareID, NativeSoftwareManagementService_ActivateImageServer) error
	// Marks the image in the Standby as Active and reboots the device, so that it boots from that image which was in the standby.
	// This API is to be used if operator wants to go back to the previous software
	RevertToStandbyImage(*HardwareID, NativeSoftwareManagementService_RevertToStandbyImageServer) error
	// This API can be used to let the devices pickup their properitary configuration which they need at startup.
	UpdateStartupConfiguration(*ConfigRequest, NativeSoftwareManagementService_UpdateStartupConfigurationServer) error
	// This API can be used to retrieve information about the current startup configuration that a device is using
	GetStartupConfigurationInfo(context.Context, *StartupConfigInfoRequest) (*StartupConfigInfoResponse, error)
	// This API can be used to upload to a remote location, information useful for troubleshooting problems on the hardware
	UploadDebugInfo(*UploadDebugInfoRequest, NativeSoftwareManagementService_UploadDebugInfoServer) error
}

// UnimplementedNativeSoftwareManagementServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNativeSoftwareManagementServiceServer struct {
}

func (*UnimplementedNativeSoftwareManagementServiceServer) GetSoftwareVersion(ctx context.Context, req *HardwareID) (*GetSoftwareVersionInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSoftwareVersion not implemented")
}
func (*UnimplementedNativeSoftwareManagementServiceServer) DownloadImage(req *DownloadImageRequest, srv NativeSoftwareManagementService_DownloadImageServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadImage not implemented")
}
func (*UnimplementedNativeSoftwareManagementServiceServer) ActivateImage(req *HardwareID, srv NativeSoftwareManagementService_ActivateImageServer) error {
	return status.Errorf(codes.Unimplemented, "method ActivateImage not implemented")
}
func (*UnimplementedNativeSoftwareManagementServiceServer) RevertToStandbyImage(req *HardwareID, srv NativeSoftwareManagementService_RevertToStandbyImageServer) error {
	return status.Errorf(codes.Unimplemented, "method RevertToStandbyImage not implemented")
}
func (*UnimplementedNativeSoftwareManagementServiceServer) UpdateStartupConfiguration(req *ConfigRequest, srv NativeSoftwareManagementService_UpdateStartupConfigurationServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateStartupConfiguration not implemented")
}
func (*UnimplementedNativeSoftwareManagementServiceServer) GetStartupConfigurationInfo(ctx context.Context, req *StartupConfigInfoRequest) (*StartupConfigInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStartupConfigurationInfo not implemented")
}
func (*UnimplementedNativeSoftwareManagementServiceServer) UploadDebugInfo(req *UploadDebugInfoRequest, srv NativeSoftwareManagementService_UploadDebugInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadDebugInfo not implemented")
}

func RegisterNativeSoftwareManagementServiceServer(s *grpc.Server, srv NativeSoftwareManagementServiceServer) {
	s.RegisterService(&_NativeSoftwareManagementService_serviceDesc, srv)
}

func _NativeSoftwareManagementService_GetSoftwareVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HardwareID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NativeSoftwareManagementServiceServer).GetSoftwareVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dmi.NativeSoftwareManagementService/GetSoftwareVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NativeSoftwareManagementServiceServer).GetSoftwareVersion(ctx, req.(*HardwareID))
	}
	return interceptor(ctx, in, info, handler)
}

func _NativeSoftwareManagementService_DownloadImage_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadImageRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NativeSoftwareManagementServiceServer).DownloadImage(m, &nativeSoftwareManagementServiceDownloadImageServer{stream})
}

type NativeSoftwareManagementService_DownloadImageServer interface {
	Send(*ImageStatus) error
	grpc.ServerStream
}

type nativeSoftwareManagementServiceDownloadImageServer struct {
	grpc.ServerStream
}

func (x *nativeSoftwareManagementServiceDownloadImageServer) Send(m *ImageStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _NativeSoftwareManagementService_ActivateImage_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HardwareID)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NativeSoftwareManagementServiceServer).ActivateImage(m, &nativeSoftwareManagementServiceActivateImageServer{stream})
}

type NativeSoftwareManagementService_ActivateImageServer interface {
	Send(*ImageStatus) error
	grpc.ServerStream
}

type nativeSoftwareManagementServiceActivateImageServer struct {
	grpc.ServerStream
}

func (x *nativeSoftwareManagementServiceActivateImageServer) Send(m *ImageStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _NativeSoftwareManagementService_RevertToStandbyImage_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HardwareID)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NativeSoftwareManagementServiceServer).RevertToStandbyImage(m, &nativeSoftwareManagementServiceRevertToStandbyImageServer{stream})
}

type NativeSoftwareManagementService_RevertToStandbyImageServer interface {
	Send(*ImageStatus) error
	grpc.ServerStream
}

type nativeSoftwareManagementServiceRevertToStandbyImageServer struct {
	grpc.ServerStream
}

func (x *nativeSoftwareManagementServiceRevertToStandbyImageServer) Send(m *ImageStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _NativeSoftwareManagementService_UpdateStartupConfiguration_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConfigRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NativeSoftwareManagementServiceServer).UpdateStartupConfiguration(m, &nativeSoftwareManagementServiceUpdateStartupConfigurationServer{stream})
}

type NativeSoftwareManagementService_UpdateStartupConfigurationServer interface {
	Send(*ConfigResponse) error
	grpc.ServerStream
}

type nativeSoftwareManagementServiceUpdateStartupConfigurationServer struct {
	grpc.ServerStream
}

func (x *nativeSoftwareManagementServiceUpdateStartupConfigurationServer) Send(m *ConfigResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NativeSoftwareManagementService_GetStartupConfigurationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartupConfigInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NativeSoftwareManagementServiceServer).GetStartupConfigurationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dmi.NativeSoftwareManagementService/GetStartupConfigurationInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NativeSoftwareManagementServiceServer).GetStartupConfigurationInfo(ctx, req.(*StartupConfigInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NativeSoftwareManagementService_UploadDebugInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UploadDebugInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NativeSoftwareManagementServiceServer).UploadDebugInfo(m, &nativeSoftwareManagementServiceUploadDebugInfoServer{stream})
}

type NativeSoftwareManagementService_UploadDebugInfoServer interface {
	Send(*UploadDebugInfoResponse) error
	grpc.ServerStream
}

type nativeSoftwareManagementServiceUploadDebugInfoServer struct {
	grpc.ServerStream
}

func (x *nativeSoftwareManagementServiceUploadDebugInfoServer) Send(m *UploadDebugInfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _NativeSoftwareManagementService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dmi.NativeSoftwareManagementService",
	HandlerType: (*NativeSoftwareManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSoftwareVersion",
			Handler:    _NativeSoftwareManagementService_GetSoftwareVersion_Handler,
		},
		{
			MethodName: "GetStartupConfigurationInfo",
			Handler:    _NativeSoftwareManagementService_GetStartupConfigurationInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadImage",
			Handler:       _NativeSoftwareManagementService_DownloadImage_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ActivateImage",
			Handler:       _NativeSoftwareManagementService_ActivateImage_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RevertToStandbyImage",
			Handler:       _NativeSoftwareManagementService_RevertToStandbyImage_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateStartupConfiguration",
			Handler:       _NativeSoftwareManagementService_UpdateStartupConfiguration_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UploadDebugInfo",
			Handler:       _NativeSoftwareManagementService_UploadDebugInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dmi/sw_management_service.proto",
}
